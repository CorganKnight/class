//Char and String

// Charactere Type
// Alias for U16
Char: Type
  U16


//Syntax Sugar for U16
  //0#16, 1#16, 2#16 ...


//Syntax Sugar for Char
  //'0', '1', '2' ... 

//Ascii Table from Wikipedia:
// https://upload.wikimedia.org/wikipedia/commons/1/1b/ASCII-Table-wide.svg

//  _________________________________________
// | U16 Syntax Sugar   | Char Syntax Sugar  |  
// |--------------------|--------------------|
// |     72#16          |      'H'           |
// |    101#16          |      'e'           |
// |    121#16          |      'y'           |
//  ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

//Verifies if the character is Upper Case

//is_upper('a') -> Bool.false
//is_upper('A') -> Bool.true
//is_upper('0') -> Bool.false
is_upper(x: Char): Bool
  case U16.gte(x, 'A') //'A' = 65
  {
    false: Bool.false
    true:  U16.lte(x, 'Z') // 'Z' = 90
  }



//Verifies if the character is Lower Case

//is_lower('a') -> Bool.true
//is_lower('A') -> Bool.false
//is_lower('0') -> Bool.false
is_lower(x: Char): Bool
  case U16.gte(x, 'a') //'a' = 97
  {
    false: Bool.false
    true: U16.lte(x, 'z') //'z' = 122
  }



//Verifies if the character is a Number-Digit Value

//is_digit('a') -> Bool.false
//is_digit('A') -> Bool.false
//is_digit('0') -> Bool.true
is_digit(x: Char): Bool
  case U16.gte(x, '0') //'0' = 48
  {
    false: Bool.false
    true:  U16.lte(x, '9') //'9' = 57
  }



//Verifies if both of the Characters are the same

//is_equal('a', 'A') -> Bool.false
//is_equal('A', '0') -> Bool.false
//is_equal('0', '0') -> Bool.true
equal(x: Char, y: Char): Bool
  U16.eql(x, y)

not_equal(x: Char, y: Char): Bool
  case U16.eql(x, y)
  {
    true:  Bool.false
    false: Bool.true
  }


//Transforms Characters into Nat digits

//to_digit('0') -> Nat.zero
//to_digit('1') -> Nat.succ(Nat.zero)
//to_digit('4') -> 4
to_digit(x: Char): Nat
  case is_digit(x)
  {
    false: Nat.zero
    true:
      case U16.eql(x, '0')
      {
        false: Nat.succ(to_digit(U16.sub(x, 1)))
        true: Nat.zero
      }
  }
// ex_10: _
//   Char.to_string(to_upper('/'))

//Transforms all Characters into Lower Case Characters

//to_lower('A') -> 'a'
//to_lower('B') -> 'b'
//to_lower('Z') -> 'z'
to_lower(x: Char): Char
  case is_upper(x)
  {
    true: U16.add(x, 32)
    false: x
  }



//Transforms all Characters into Upper Case Characters

//to_upper('a') -> 'A' 
//to_upper('b') -> 'B'
//to_upper('z') -> 'Z'
to_upper(x: Char): Char
  case is_lower(x)
  {
    true: U16.sub(x, 32)
    false: x
  }





//String Type
type String { 
  nil,
  cons(head: Char, tail: String)
}

//Without Syntax Sugar for String
//a = String.cons('H', String.cons('I', String.nil))
//b = String.cons('H', String.cons('e', String.cons('l', String.cons('l', String.cons('o', String.nil)))))
//c = String.cons('t', String.cons('e', String.cons('x', String.cons('t', String.nil))))

//Syntax Sugar for String
//a = "HI"
//b = "Hello"
//c = "text"



//Concatenates two Strings into one

//concat(a,b) -> "HiHello"
//concat(b,c) -> "Hellotext"
concat(xs: String, ys: String): String
  case xs ys
  {
    nil   nil: String.nil
    cons  nil: xs
    nil  cons: ys 
    cons cons: String.cons(xs.head, concat(xs.tail, ys))
  }

concatrev(xs: String, ys: String): String
  concat(ys, xs)

// ex_10:_
//   concatrev("test", "play")
//Drops a n Number of characteres from a String

//drop(1, a) -> "I"
//drop(2, b) -> "llo"
//drop(3, c) -> "t"
drop(n: Nat, xs: String): String
  case n
  {
    zero: xs
    succ: 
      case xs
      {
        nil: String.nil
        cons: drop(n.pred, xs.tail)
      }
  }





//Takes n elements of a String

//take(1, a) ->  "H"
//take(2, b) ->  "He"
//take(3, c) ->  "tex"
take(n: Nat xs: String): String
  case n
  {
    zero: String.nil
    succ: 
      case xs
      {
        nil: String.nil
        cons: String.cons(xs.head, take(n.pred, xs.tail))
      }
  }


//Takes a x part of the string after an n Index of values get dropped

//slice(1, 2, a) -> "I"
//slice(2, 4, b) -> "ll"
//slice(1, 2, c) -> "ex"
slice(n: Nat, x: Nat, xs: String): String
  take(x, drop(n, xs))

//  ex_10:_
//    slice(2, 4, "Hello")

//Filters the String and discards all the Chars that doesn't satisfy given condition 

//filter(is_upper,      a) -> "HI"
//filter(is_lower,      b) -> "ello"
//filter(is_equal('t'), c) -> "tt"
filter(cond: Char -> Bool, xs: String): String
  case xs
  {
    nil:  String.nil
    cons: 
      case cond(xs.head)
      {
        false: filter(cond, xs.tail)
        true:  String.cons(xs.head, filter(cond, xs.tail))
      }
  }



//Applies a Function to all Characters of the String

//map(to_lower, a) -> "hi"
map(fn: Char -> Char, xs: String): String
  case xs
  {
    nil: String.nil
    cons: String.cons(fn(xs.head), map(fn, xs.tail))
  }



//Converts all Lower Case Caracters in a String to Upper Case

//string_to_upper(c) -> "TEXT"
string_to_upper(xs: String): String
  map(to_upper, xs)



//Converts the String into bits

//to_bits(a) -> "0000000001001001 0000000001001000"
//to_bits(b) -> "0000000001101111 0000000001101100 00000000011011000 000000001100101 0000000001001000"
//to_bits(c) -> "0000000001110100 0000000001111000 00000000011001010 000000001110100"
to_bits(xs: String): Bits
  case xs
  {
    nil:  Bits.e
    cons: Bits.concat(U16.to_bits(xs.head), to_bits(xs.tail))
  }



//Verifies if two Strings are Equal

//stringequal(a, a) -> Bool.true
//stringequal(a, b) -> Bool.false
//stringequal(b, c) -> Bool.false
stringequal(xs: String, ys: String): Bool
  case xs ys
  {
    nil nil:   Bool.true
    cons cons: 
      case equal(xs.head, ys.head)
      {
        true:  stringequal(xs.tail, ys.tail)
        false: Bool.false
      }
  } default Bool.false


//Verifies if All String elements are Numbers

//is_nat(a)      -> Bool.false
//is_nat(b)      -> Bool.false
//is_nat("1234") -> Bool.true
is_nat(xs: String): Bool
  case xs
  {
    nil:  Bool.false
    cons: 
      case is_digit(xs.head)
      {
        true:  
          case xs.tail
          {
            nil: Bool.true
            cons: is_nat(xs.tail)
          }
        false: Bool.false
      }
  }

 



// Divides the elements of a String into a list, using a match you decide

//split(b, "l") -> ["He","" , "o"]
//split(c, "e") -> ["t", "xt"]
//split(c, "ex") ->["t", "t"]
//split("I am your friend", "ou") ["I am y", "r friend"]
//split("I am your friend", " ") ["I", "am", "your" "friend"]

split(xs: String, match: String): List<String>
  case xs match{
    cons nil:  List.cons<String>(xs, List.nil<String>)
    cons cons: split.go(xs, match, xs, 0, 0, 0)
  } default List.nil<String>
  


split.go(xs: String, match: String, xsi: String, tc: Nat, fc: Nat, gc: Nat): List<String>
  case xs match
  {
    nil  cons: List.cons<String>(slice((gc - fc), fc, xsi), List.nil<String>)
    cons cons:
      case stringequal(take(String.length(match), xs), match)
      {
        true:  
          case tc
          {
            zero: List.cons<String>(take(fc, xsi), split.go(drop(String.length(match), xs), match, xsi, Nat.succ(tc), 0, gc + String.length(match)))
            succ: List.cons<String>(slice((gc - fc), fc, xsi), split.go(drop(String.length(match), xs), match, xsi, Nat.succ(tc), 0, gc + String.length(match)))
          }
        false: split.go(xs.tail, match, xsi, tc, Nat.succ(fc), Nat.succ(gc))
      }
  } default List.nil<String>
      // case fc
      //   {
      //     zero: List.nil<String>
      //     succ: List.cons<String>(slice((fc + tc), fc, xsi), split.go(drop(gc, xsi), match, xsi, Nat.succ(tc), 0, gc + String.length(match)))
      //   }


// split.go("You are mine", " ", "You are mine", 0, 0, 0)
//   false: split.go("ou are mine", " ", "You are mine", 0, 1, 1)
//          false: split.go("u are mine", " ", "You are mine", 0, 2, 2)
//                 false: split.go(" are mine", " ", "You are mine", 0, 3, 3)
//                        true zero: List.cons(take(3, "You are mine"), split.go("are mine", " ", "You are mine", 1, 0, 4))
//                                                                      false: split.go("re mine", " ", "You are mine", 1, 1, 5)
//                                                                             false: split.go("e mine", " ", "You are mine", 1, 2, 6)
//                                                                                    false: split.go(" mine", " ", "You are mine", 1, 3, 7)
//                                                                                           true succ: List.cons(slice(4, 3 "You are mine"), split.go("mine", " ", "You are mine", 2, 0, 8))
//                                                                                                                                            false: split.go("ine", " ", "You are mine", 2, 1, 9)
//                                                                                                                                                   false: split.go("ne", " ", "You are mine", 2, 2, 10)
//                                                                                                                                                          false: split.go("e", " ", "You are mine", 2, 3, 11)
//                                                                                                                                                                 false: split.go("", " ", "You are mine", 2, 4, 12)
//                                                                                                                                                                        nil: List.cons(slice(8, 4, "You are mine"), List.nil<String>)


// ex_10:_
//  List.show!((x)x, split("Hello", "l",))

// Takes any elements of a string that matches the given condition

//take_while(is_upper,    a) -> "HI"
//take_while(is_lower,    b) -> ""
//take_while(is_equal('t'), c) -> "t"
take_while(cond: Char -> Bool, xs: String): String
  case xs
  {
    nil:  String.nil
    cons: 
      case cond(xs.head)
      {
        true:  String.cons(xs.head, take_while(cond, xs.tail))
        false: take_while(cond, xs.tail)
      }
  }



take_until(cond: Char -> Bool, xs: String): String
  case xs
  {
    nil:  String.nil
    cons: 
      case cond(xs.head)
      {
        true:  String.nil
        false: String.cons(xs.head, take_until(cond, xs.tail))
      }
  }

//  ex_10:_
//    take_until(equal(' '), "You are the only exception")


//Finds the index of the head for the first occurence if any of the Characters are equal

//find(a, "H") -> Maybe.some(0)
//find(b, "l") -> Maybe.some(2)
//find(c, "x") -> Maybe.some(2)
//find(c, "z") -> Maybe.none
find(xs: String, x: Char): Maybe<Nat>
  ?find
//find(a, "H") -> 0
//find(b, "l") -> 2
//find(c, "x") -> 2
find(xs: String, x: Char): Nat
  case xs
  {
    nil: Nat.zero
    cons: 
      case equal(xs.head, x)
      {
        true:  Nat.zero
        false: Nat.succ(find(xs.tail, x))
      }
  }

// ex_10:_
//   flatten(["Hi", "Hello", "text"])

//Concatenates all elements of a List of Strings

//flatten([a,b,c]) -> "HIHellotext"
flatten(lxs: List<String>): String
  case lxs
  {
    nil: String.nil
    cons: concat(lxs.head, flatten(lxs.tail))
  }



//functions from previous lists that I copied here in order to use them

init<A: Type>(xs: List<A>): List<A>
  case xs
  {
    nil: List.nil<A>
    cons:
      case xs.tail
      {
        nil: List.nil<A>
        cons: List.cons<A>(xs.head, init<A>(xs.tail))
      }
  }

last<A: Type>(xs: List<A>): Maybe<A>
  case xs
  {
    nil: Maybe.none<A>
    cons: 
      case xs.tail
      {
        nil: Maybe.some<A>(xs.head)
        cons: last<A>(xs.tail)
      }
  }


Find_and_replace(to_remove: String, to_add: String, str: String): String
  String.concat(String.flatten(List.map<String, String>(concatrev(to_add), init<String>(split(str, to_remove)))), last<String>(split(str, to_remove)) <> "")




ex_10: _
  Find_and_replace("the word", "penis", "In this test, the word test should be replaced by the word example")

   //List.show!((x) x, List.map<String, String>(concatrev("example"), List.init<String>(split("In this test, the word test should be replaced by the word example.", "test"))))
  // This should be the result: "In this example, the word example should be replaced by the word example." 

  //String.flatten(List.map<String, String>(concatrev("example"), init<String>(split(str, to_remove))))
  
  // ["In this ", ", the word ", " should be replaced by the word example"] = xs

  // init(xs) = ["In this ", ", the word "] ==> xsnl


  // map<String, String>(concatrev("example"), xsnl) = ["In this example", ", the word example"] ==> rep_list

  // flatten(replaced) = "In this example, the word example" ==> rep_str

  // concat(rep_str, Maybe.extract.value<String>(last(xs)))


ex_10: IO<Unit>
  IO {
    Tests._10.is_upper(is_upper)
    Tests._10.is_lower(is_lower)
    Tests._10.is_digit(is_digit)
    Tests._10.equal(equal)
    Tests._10.to_digit(to_digit)
    Tests._10.to_lower(to_lower)
    Tests._10.to_upper(to_upper)
    Tests._10.concat(concat)
    Tests._10.drop(drop)
    Tests._10.take(take)
    Tests._10.slice(slice)
    Tests._10.filter(filter)
    Tests._10.map(map)
    Tests._10.string_to_upper(string_to_upper)
    Tests._10.to_bits(to_bits)
    Tests._10.stringequal(stringequal)
    Tests._10.is_nat(is_nat)
    Tests._10.take_while(take_while)
    Tests._10.find(find) 
    Tests._10.flatten(flatten)
  }