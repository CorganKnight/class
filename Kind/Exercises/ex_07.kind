//Bits

//File for exercises in Bits

//e = empty
//o = 0
//i = 1
type Bits {
  e
  o(pred: Bits)
  i(pred: Bits)
}

//a = Bits.i(Bits.i(Bits.e))
//b = Bits.o(Bits.i(Bits.i(Bits.e)))
//c = Bits.o(Bits.o(Bits.i(Bits.i(Bits.e))))
//d = Bits.i(Bits.i(Bits.i(Bits.i(Bits.e))))


//Verifies if it is an Empty Bit

//is_empty(a)      -> Bool.false
//is_empty(b)      -> Bool.false
//is_empty(c)      -> Bool.false
//is_empty(d)      -> Bool.false
//is_empty(Bits.e) -> Bool.true
is_empty(b: Bits): Bool
  case b
  {
    e: Bool.true
  } default Bool.false



//Gets the Tail of a Bits structure

//tail(a) -> Bits.i(Bits.e)
//tail(b) -> Bits.i(Bits.i(Bits.e))
//tail(c) -> Bits.o(Bits.i(Bits.i(Bits.e)))
//tail(d) -> Bits.i(Bits.i(Bits.i(Bits.e)))
tail(b: Bits): Bits
  case b
  {
    e: Bits.e
  } default b.pred


//Negates all Bits

//not(a) -> Bits.o(Bits.o(Bits.e))
//not(b) -> Bits.i(Bits.o(Bits.o(Bits.e)))
//not(c) -> Bits.i(Bits.i(Bits.o(Bits.o(Bits.e))))
//not(d) -> Bits.o(Bits.o(Bits.o(Bits.o(Bits.e))))
bits.not(b: Bits): Bits
  case b
  {
    e: Bits.e
    i: Bits.o(bits.not(b.pred))
    o: Bits.i(bits.not(b.pred))
  }




//Increments a Bit

//inc(a) -> Bits.o(Bits.o(Bits.i(Bits.e)))
//inc(b) -> Bits.i(Bits.i(Bits.i(Bits.e)))
//inc(c) -> Bits.i(Bits.o(Bits.i(Bits.i(Bits.e))))
//inc(d) -> Bits.o(Bits.o(Bits.o(Bits.o(Bits.i(Bits.e)))))
bits.inc(b: Bits): Bits
  case b
  {
    e: Bits.i(Bits.e)
    i: Bits.o(bits.inc(b.pred))
    o: Bits.i(b.pred)
  }


//Decrements a Bit

//dec(a) -> Bits.o(Bits.i(Bits.e))
//dec(b) -> Bits.i(Bits.o(Bits.i(Bits.e)))
//dec(c) -> Bits.i(Bits.i(Bits.o(Bits.i(Bits.e))))
//dec(d) -> Bits.o(Bits.i(Bits.i(Bits.i(Bits.e))))
dec(b: Bits): Bits
  case b
  {
    e: Bits.e
    i: 
      case b.pred
      {
        e: b.pred
      } default Bits.o(b.pred)
    o: 
      case b.pred
      {
        e: b.pred
      } default Bits.i(dec(b.pred))
  }

dec2(b: Bits): Bits
  case b
  {
    e: Bits.e
    i: Bits.o(b.pred)
    o: Bits.i(dec2(b.pred))
  }

dec.ss(b: Bits): Bits
  case b
  {
    e: Bits.e
    o: Bits.i(dec(b.pred))
    i: Bits.o(b.pred)
  }


dec.ro(b: Bits): Bits
  case dec(b)
  {
    e: Bits.o(Bits.e)
  } default dec(b)

dec.s(b: Bits): Bits
  dec2(fix_bits(b))

// ex_07:_
// dec((Bits.o(Bits.e)))

//Concatenate two Bits structures

//concat(a,b) -> Bits.i(Bits.i(Bits.o(Bits.i(Bits.i(Bits.e)
//concat(b,c) -> Bits.o(Bits.i(Bits.i(Bits.o(Bits.o(Bits.i(Bits.i(Bits.e)))))))
//concat(c,d) -> Bits.o(Bits.o(Bits.i(Bits.i(Bits.i(Bits.i(Bits.i(Bits.i(Bits.e))))))))
concat(a: Bits, b: Bits): Bits
  case a
  {
    e: b
    i: Bits.i(concat(a.pred, b))
    o: Bits.o(concat(a.pred, b))
  }


// concat(Bits.i(Bits.o(Bits.e)), Bits.o(Bits.i(Bits.i(Bits.e))))
// i: Bits.i(concat(Bits.o(Bits.e), Bits.o(Bits.i(Bits.i(Bits.e)))))
//           o: Bits.o(concat(Bits.e, Bits.o(Bits.i(Bits.i(Bits.e)))))
//                     e: Bits.o(Bits.i(Bits.i(Bits.e)))




//Adds two Bits structures

//add(a,b) -> Bits.i(Bits.o(Bits.o(Bits.i(Bits.e))))
//add(b,c) -> Bits.o(Bits.i(Bits.o(Bits.o(Bits.i(Bits.o(Bits.e))))))
//add(c,d) -> Bits.i(Bits.i(Bits.o(Bits.i(Bits.o(Bits.i(Bits.e))))))
add(a: Bits, b: Bits): Bits 
  case b
  {
    e: a

  } default 
      case a
      {
        e: b
        o: 
          case a.pred
          {
            e: b
          } default bits.inc(add(dec.s(a), (b)))
            i: bits.inc(add(dec.s(a), (b)))
     }


add2(a: Bits, b: Bits): Bits
  case a b
  {
    i i: Bits.o(bits.inc(add(a.pred, b.pred)))
    i o: Bits.i(add(a.pred, b.pred))
    o i: Bits.i(add(a.pred, b.pred))
    o o: Bits.o(add(a.pred, b.pred))
    i e: a
    o e: a
    e i: b
    e o: b
    e e: Bits.e
  }

//Returns Bits.i if only both bits are Bits.i



//and(a,b) -> Bits.o(Bits.i(Bits.e))
//and(b,c) -> Bits.o(Bits.o(Bits.i(Bits.e)))
//and(c,d) -> Bits.o(Bits.o(Bits.i(Bits.i(Bits.e))))
and(a: Bits, b: Bits): Bits
  case a b
  {
    i i: Bits.i(and(a.pred, b.pred))
    o i: Bits.o(and(a.pred, b.pred))
    i o: Bits.o(and(a.pred, b.pred))
    o o: Bits.o(and(a.pred, b.pred))
  } default Bits.e



//Returns Bits.i if any of bits are Bits.i

//or(a,b) -> Bits.i(Bits.i(Bits.i(Bits.e)))
//or(b,c) -> Bits.o(Bits.i(Bits.i(Bits.i(Bits.e))))
//or(c,d) -> Bits.i(Bits.i(Bits.i(Bits.i(Bits.e))))
or(a: Bits, b: Bits): Bits
  case a b
  {
    i e: Bits.e
    i o: Bits.i(or(a.pred, b.pred))
    i i: Bits.i(or(a.pred, b.pred))
    o i: Bits.i(or(a.pred, b.pred))
    o o: Bits.o(or(a.pred, b.pred))
    o e: Bits.e
    e o: Bits.e
    e i: Bits.e 
    e e: Bits.e
  }



//Verifies if both Bit structures are equal

//eql(a,b) -> Bool.false
//eql(b,c) -> Bool.false
//eql(d,d) -> Bool.true
eql(a: Bits, b: Bits): Bool
 case a b
 {
   e e: Bool.true
   i i: eql(a.pred, b.pred)
   o o: eql(a.pred, b.pred)
 } default Bool.false



//Reverses a Bits structure

reverse_go(b: Bits, acum: Bits): Bits
  case b
  {
    e: acum
    i: reverse_go(b.pred, Bits.i(acum))
    o: reverse_go(b.pred, Bits.o(acum))
  }
  


//reverse(a) -> Bits.i(Bits.i(Bits.e))
//reverse(b) -> Bits.i(Bits.i(Bits.o(Bits.e)))
//reverse(c) -> Bits.i(Bits.i(Bits.o(Bits.o(Bits.e))))
//reverse(d) -> Bits.i(Bits.i(Bits.i(Bits.i(Bits.e))))
reverse(b: Bits): Bits
  reverse_go(b, Bits.e)




//Gets the length of the Bits structure
//length(a) -> Nat.succ(Nat.succ(Nat.zero))
//length(b) -> Nat.succ(Nat.succ(Nat.succ(Nat.zero)))
//length(c) -> Nat.succ(Nat.succ(Nat.succ(Nat.succ(Nat.zero))))
//length(d) -> 4
length(bs: Bits): Nat
  case bs
  {
    e: Nat.zero
  } default Nat.succ(length(bs.pred))

//Multiplies two Bits structures

mul_go(a: Bits, b: Bits, c: Bits, d: Bits): Bits
   case a b
   {
     e e: Bits.e
     e i: Bits.e
     e o: Bits.e
     o e: Bits.e
     i e: Bits.e
   } default 
      case c
      {
        e: Bits.e
      } default 
          case d
          {
            e: mul_go(a, b, dec(c), b)
            i: bits.inc(mul_go(a, b, c, dec(d)))
          } default 
              case d.pred
              {
                e: Bits.o(Bits.e)
              } default bits.inc(mul_go(a, b, c, dec(d)))

inCRIMEnta(b: Bits): Bits
  case b
  {
    e: Bits.o(Bits.e)
  } default b

Bits_reduce(b: Bits): Bits
  case b
  {
    o: 
      case is_empty(b.pred)
      {
        true: b
        false: Bits_reduce(b.pred)
      }
  } default b

fix_bits(b: Bits): Bits
  reverse(Bits_reduce(reverse(b)))

// Bits_reduce(Bits.o(Bits.o(Bits.o(Bits.e))))  == Bits.o(Bits.e)
//   o false: Bits_reduce(Bits.o(Bits.o(Bits.e)))
//            o false: Bits_reduce(Bits.o(Bits.e))
//                     o true: Bits.o(Bits.e)

// mul_go(100, 0, 100, 0)
//   default Bits.o(Bits.e)
//                      default Bits.e
//                              default inCRIMEnta(Bits.o(Bits.e))
//                                      default Bits.o(Bits.e)
//                                              default Bits.o(Bits.e)
//                                                                 default Bits.e
//                                                                         c (e): Bits.e


//mul(a,b) -> Bits.o(Bits.i(Bits.o(Bits.o(Bits.i(Bits.e)))))
//mul(b,c) -> Bits.o(Bits.o(Bits.o(Bits.i(Bits.o(Bits.o(Bits.i(Bits.e)))))))
mul(a: Bits, b: Bits): Bits
  let aa = fix_bits(a)
  let bb = fix_bits(b)
 case a
 {
   o: 
    case a.pred
    {
      e: Bits.o(Bits.e)
    } default mul_go(aa, bb, aa, bb)
 } default mul_go(aa, bb, aa, bb)
  



//Drops a n Number of Bits starting from from the least significative bit

//a = Bits.i(Bits.i(Bits.e))
//b = Bits.o(Bits.i(Bits.i(Bits.e)))
//c = Bits.o(Bits.o(Bits.i(Bits.i(Bits.e))))
//d = Bits.i(Bits.i(Bits.i(Bits.i(Bits.e))))

//drop(a) -> Bits.i(Bits.e)
//drop(b) -> Bits.i(Bits.i(Bits.e))
//drop(c) -> Bits.o(Bits.i(Bits.i(Bits.e)))
//drop(d) -> Bits.i(Bits.i(Bits.i(Bits.e)))
drop(n: Nat, bs: Bits): Bits
  case n
  {
    zero: bs
    succ: 
      case bs
      {
        e: Bits.e
      } default drop(n.pred, bs.pred)
  }
  


//Takes n Bits from the structure, starting from the least significative bit

//take(1, a) -> Bits.i(Bits.e)
//take(2, b) -> Bits.o(Bits.i(Bits.e))
//take(3, c) -> Bits.o(Bits.o(Bits.i(Bits.e)))
//take(4, d) -> Bits.i(Bits.i(Bits.i(Bits.i(Bits.e))))
take(n: Nat, bs: Bits): Bits
  case n
  {
    zero: Bits.e
    succ: 
      case bs
      {
        e: Bits.e
        i: Bits.i(take(n.pred, bs.pred))
        o: Bits.o(take(n.pred, bs.pred))
      }
  }

Nat.to_bits(n: Nat): Bits
  case n {
    zero: Bits.o(Bits.e),
    succ: Bits.inc(Nat.to_bits(n.pred))
  }


div_go(a: Bits, b: Bits, c: Bits, d: Bits): Bits
  case a b
  {
    e i: Bits.e
    e o: Bits.e
    i e: Bits.e
    e o: Bits.e
    e e: Bits.e
  } default 
      case c
      {
        e: 
          case d
          {
            e: bits.inc(Bits.e)
          } default Bits.e
      } default 
          case d
          {
            e: bits.inc(div_go(a, b, c, b))
          } default div_go(a, b, dec(c), dec(d))


// div_go(Bits.o(Bits.o(Bits.i(Bits.e))), Bits.o(Bits.i(Bits.e)), Bits.o(Bits.o(Bits.i(Bits.e))), (Bits.o(Bits.i(Bits.e))))
//   default: div_go(a, b, Bits.i(Bits.i(Bits.e)), (Bits.i(Bits.e)))
//            default: div_go(a, b, Bits.o(Bits.i(Bits.e)), Bits.e)
//                     d = e: bits.inc(div_go(a, b, Bits.o(Bits.i(Bits.e)), Bits.o(Bits.i(Bits.e))))

div(a: Bits, b: Bits): Bits
  case a b
  {
    e e: Bits.e
    o o: 
      case a.pred b.pred
      {
        e e: Bits.o(Bits.e)
      } default div_go(a, b, a, b)
  } default div_go(a, b, a, b)


ex_07: _
  //fix_bits(Bits.o(Bits.o(Bits.o(Bits.o(Bits.o(Bits.o(Bits.o(Bits.o(Bits.e)))))))))
  Nat.div(6, 0)
// ex_07: IO<Unit>
//   IO {
//     Tests._07.is_empty(is_empty)
//     Tests._07.tail(tail)
//     Tests._07.not(bits.not)
//     Tests._07.inc(bits.inc)
//     Tests._07.dec(dec.s)
//     Tests._07.concat(concat)
//     Tests._07.add(add2)
//     Tests._07.and(and)
//     Tests._07.or(or)
//     Tests._07.eql(eql)
//     Tests._07.reverse(reverse)
//     Tests._07.length(length)
//     Tests._07.mul(mul)
//     Tests._07.drop(drop)
//     Tests._07.take(take)
//   }